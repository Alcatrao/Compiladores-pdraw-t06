# Generated from ipdraw.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,57,227,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,1,0,5,0,26,8,0,10,
        0,12,0,29,9,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,5,1,39,8,1,10,1,12,
        1,42,9,1,1,1,1,1,1,1,1,1,1,1,3,1,49,8,1,1,2,1,2,3,2,53,8,2,1,2,1,
        2,1,2,1,2,1,2,3,2,60,8,2,1,2,1,2,1,2,1,2,3,2,66,8,2,1,2,1,2,3,2,
        70,8,2,1,2,1,2,1,2,1,2,3,2,76,8,2,1,2,1,2,1,2,1,2,1,2,3,2,83,8,2,
        1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
        1,2,1,2,3,2,103,8,2,1,2,1,2,1,2,1,2,1,2,3,2,110,8,2,1,2,1,2,1,2,
        1,2,1,2,1,2,3,2,118,8,2,1,3,3,3,121,8,3,1,3,1,3,1,3,1,3,1,3,1,3,
        1,3,1,3,5,3,131,8,3,10,3,12,3,134,9,3,1,3,3,3,137,8,3,1,4,1,4,1,
        4,1,4,5,4,143,8,4,10,4,12,4,146,9,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,
        1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,163,8,5,1,5,1,5,1,5,1,5,1,5,
        1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,5,5,180,8,5,10,5,12,5,183,
        9,5,1,6,1,6,1,6,1,6,1,6,1,6,3,6,191,8,6,1,7,1,7,1,7,1,7,1,7,1,7,
        3,7,199,8,7,1,8,1,8,4,8,203,8,8,11,8,12,8,204,3,8,207,8,8,1,8,1,
        8,1,8,1,8,1,9,1,9,1,9,1,9,1,10,1,10,3,10,219,8,10,1,11,1,11,1,11,
        1,11,1,11,1,11,1,11,0,1,10,12,0,2,4,6,8,10,12,14,16,18,20,22,0,7,
        1,0,8,9,1,0,22,23,1,0,24,25,1,0,26,28,1,0,29,34,1,0,35,40,1,0,41,
        42,264,0,27,1,0,0,0,2,48,1,0,0,0,4,117,1,0,0,0,6,120,1,0,0,0,8,138,
        1,0,0,0,10,162,1,0,0,0,12,184,1,0,0,0,14,192,1,0,0,0,16,206,1,0,
        0,0,18,212,1,0,0,0,20,216,1,0,0,0,22,220,1,0,0,0,24,26,3,2,1,0,25,
        24,1,0,0,0,26,29,1,0,0,0,27,25,1,0,0,0,27,28,1,0,0,0,28,30,1,0,0,
        0,29,27,1,0,0,0,30,31,5,0,0,1,31,1,1,0,0,0,32,49,3,4,2,0,33,49,3,
        12,6,0,34,49,3,14,7,0,35,49,3,16,8,0,36,40,5,1,0,0,37,39,3,2,1,0,
        38,37,1,0,0,0,39,42,1,0,0,0,40,38,1,0,0,0,40,41,1,0,0,0,41,43,1,
        0,0,0,42,40,1,0,0,0,43,49,5,2,0,0,44,49,3,6,3,0,45,49,3,8,4,0,46,
        49,3,18,9,0,47,49,3,20,10,0,48,32,1,0,0,0,48,33,1,0,0,0,48,34,1,
        0,0,0,48,35,1,0,0,0,48,36,1,0,0,0,48,44,1,0,0,0,48,45,1,0,0,0,48,
        46,1,0,0,0,48,47,1,0,0,0,49,3,1,0,0,0,50,52,5,3,0,0,51,53,5,4,0,
        0,52,51,1,0,0,0,52,53,1,0,0,0,53,54,1,0,0,0,54,55,3,22,11,0,55,56,
        5,5,0,0,56,118,1,0,0,0,57,59,5,6,0,0,58,60,5,4,0,0,59,58,1,0,0,0,
        59,60,1,0,0,0,60,61,1,0,0,0,61,62,5,48,0,0,62,118,5,5,0,0,63,65,
        5,7,0,0,64,66,5,4,0,0,65,64,1,0,0,0,65,66,1,0,0,0,66,67,1,0,0,0,
        67,69,3,10,5,0,68,70,7,0,0,0,69,68,1,0,0,0,69,70,1,0,0,0,70,71,1,
        0,0,0,71,72,5,5,0,0,72,118,1,0,0,0,73,75,5,10,0,0,74,76,5,4,0,0,
        75,74,1,0,0,0,75,76,1,0,0,0,76,77,1,0,0,0,77,78,3,10,5,0,78,79,5,
        5,0,0,79,118,1,0,0,0,80,82,5,11,0,0,81,83,5,4,0,0,82,81,1,0,0,0,
        82,83,1,0,0,0,83,84,1,0,0,0,84,85,3,10,5,0,85,86,5,5,0,0,86,118,
        1,0,0,0,87,88,5,12,0,0,88,118,5,5,0,0,89,90,5,13,0,0,90,118,5,5,
        0,0,91,92,5,14,0,0,92,93,3,10,5,0,93,94,5,5,0,0,94,118,1,0,0,0,95,
        96,5,15,0,0,96,97,3,10,5,0,97,98,5,5,0,0,98,118,1,0,0,0,99,100,5,
        16,0,0,100,102,3,10,5,0,101,103,7,0,0,0,102,101,1,0,0,0,102,103,
        1,0,0,0,103,104,1,0,0,0,104,105,5,5,0,0,105,118,1,0,0,0,106,107,
        5,17,0,0,107,109,3,10,5,0,108,110,7,0,0,0,109,108,1,0,0,0,109,110,
        1,0,0,0,110,111,1,0,0,0,111,112,5,5,0,0,112,118,1,0,0,0,113,114,
        5,18,0,0,114,115,3,10,5,0,115,116,5,5,0,0,116,118,1,0,0,0,117,50,
        1,0,0,0,117,57,1,0,0,0,117,63,1,0,0,0,117,73,1,0,0,0,117,80,1,0,
        0,0,117,87,1,0,0,0,117,89,1,0,0,0,117,91,1,0,0,0,117,95,1,0,0,0,
        117,99,1,0,0,0,117,106,1,0,0,0,117,113,1,0,0,0,118,5,1,0,0,0,119,
        121,5,49,0,0,120,119,1,0,0,0,120,121,1,0,0,0,121,122,1,0,0,0,122,
        123,5,50,0,0,123,124,5,4,0,0,124,125,3,10,5,0,125,132,1,0,0,0,126,
        127,5,19,0,0,127,128,5,50,0,0,128,129,5,4,0,0,129,131,3,10,5,0,130,
        126,1,0,0,0,131,134,1,0,0,0,132,130,1,0,0,0,132,133,1,0,0,0,133,
        136,1,0,0,0,134,132,1,0,0,0,135,137,5,5,0,0,136,135,1,0,0,0,136,
        137,1,0,0,0,137,7,1,0,0,0,138,139,5,49,0,0,139,144,5,50,0,0,140,
        141,5,19,0,0,141,143,5,50,0,0,142,140,1,0,0,0,143,146,1,0,0,0,144,
        142,1,0,0,0,144,145,1,0,0,0,145,147,1,0,0,0,146,144,1,0,0,0,147,
        148,5,5,0,0,148,9,1,0,0,0,149,150,6,5,-1,0,150,151,5,20,0,0,151,
        152,3,10,5,0,152,153,5,21,0,0,153,163,1,0,0,0,154,155,7,1,0,0,155,
        163,3,10,5,12,156,163,5,52,0,0,157,163,5,51,0,0,158,163,5,53,0,0,
        159,163,5,50,0,0,160,163,3,22,11,0,161,163,5,54,0,0,162,149,1,0,
        0,0,162,154,1,0,0,0,162,156,1,0,0,0,162,157,1,0,0,0,162,158,1,0,
        0,0,162,159,1,0,0,0,162,160,1,0,0,0,162,161,1,0,0,0,163,181,1,0,
        0,0,164,165,10,11,0,0,165,166,7,2,0,0,166,180,3,10,5,12,167,168,
        10,10,0,0,168,169,7,3,0,0,169,180,3,10,5,11,170,171,10,9,0,0,171,
        172,7,4,0,0,172,180,3,10,5,10,173,174,10,8,0,0,174,175,7,5,0,0,175,
        180,3,10,5,9,176,177,10,7,0,0,177,178,7,6,0,0,178,180,3,10,5,8,179,
        164,1,0,0,0,179,167,1,0,0,0,179,170,1,0,0,0,179,173,1,0,0,0,179,
        176,1,0,0,0,180,183,1,0,0,0,181,179,1,0,0,0,181,182,1,0,0,0,182,
        11,1,0,0,0,183,181,1,0,0,0,184,185,5,43,0,0,185,186,5,20,0,0,186,
        187,3,10,5,0,187,188,5,21,0,0,188,190,3,2,1,0,189,191,5,5,0,0,190,
        189,1,0,0,0,190,191,1,0,0,0,191,13,1,0,0,0,192,193,5,44,0,0,193,
        194,5,20,0,0,194,195,3,10,5,0,195,196,5,21,0,0,196,198,3,2,1,0,197,
        199,5,5,0,0,198,197,1,0,0,0,198,199,1,0,0,0,199,15,1,0,0,0,200,207,
        5,50,0,0,201,203,5,54,0,0,202,201,1,0,0,0,203,204,1,0,0,0,204,202,
        1,0,0,0,204,205,1,0,0,0,205,207,1,0,0,0,206,200,1,0,0,0,206,202,
        1,0,0,0,207,208,1,0,0,0,208,209,5,45,0,0,209,210,5,46,0,0,210,211,
        5,5,0,0,211,17,1,0,0,0,212,213,5,18,0,0,213,214,3,10,5,0,214,215,
        5,5,0,0,215,19,1,0,0,0,216,218,5,47,0,0,217,219,5,5,0,0,218,217,
        1,0,0,0,218,219,1,0,0,0,219,21,1,0,0,0,220,221,5,20,0,0,221,222,
        3,10,5,0,222,223,5,19,0,0,223,224,3,10,5,0,224,225,5,21,0,0,225,
        23,1,0,0,0,24,27,40,48,52,59,65,69,75,82,102,109,117,120,132,136,
        144,162,179,181,190,198,204,206,218
    ]

class ipdrawParser ( Parser ):

    grammarFileName = "ipdraw.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'{'", "'}'", "'position'", "'='", "';'", 
                     "'color'", "'orientation'", "'\\u00BA'", "'rad'", "'thickness'", 
                     "'pressure'", "'down'", "'up'", "'forward'", "'backward'", 
                     "'left'", "'right'", "'pause'", "','", "'('", "')'", 
                     "'not'", "'!'", "'and'", "'&&'", "'or'", "'||'", "'xor'", 
                     "'=='", "'!='", "'<='", "'<'", "'>='", "'>'", "'*'", 
                     "'/'", "'//'", "'%'", "'\\'", "'**'", "'+'", "'-'", 
                     "'if'", "'until'", "'->'", "'stdout'", "'interactador'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "Color", "TYPE", "ID", "INT", "REAL", "BOOL", "STRING", 
                      "RGBHex", "Comment", "WS" ]

    RULE_program = 0
    RULE_stat = 1
    RULE_penCommand = 2
    RULE_varAssignment = 3
    RULE_varDeclaration = 4
    RULE_expr = 5
    RULE_if = 6
    RULE_until = 7
    RULE_print = 8
    RULE_pause = 9
    RULE_interactador = 10
    RULE_point = 11

    ruleNames =  [ "program", "stat", "penCommand", "varAssignment", "varDeclaration", 
                   "expr", "if", "until", "print", "pause", "interactador", 
                   "point" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    Color=48
    TYPE=49
    ID=50
    INT=51
    REAL=52
    BOOL=53
    STRING=54
    RGBHex=55
    Comment=56
    WS=57

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ipdrawParser.EOF, 0)

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.StatContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.StatContext,i)


        def getRuleIndex(self):
            return ipdrawParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = ipdrawParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 27
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 19870374137691338) != 0):
                self.state = 24
                self.stat()
                self.state = 29
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 30
            self.match(ipdrawParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ipdrawParser.RULE_stat

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Stat_varAssignmentContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def varAssignment(self):
            return self.getTypedRuleContext(ipdrawParser.VarAssignmentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_varAssignment" ):
                listener.enterStat_varAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_varAssignment" ):
                listener.exitStat_varAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_varAssignment" ):
                return visitor.visitStat_varAssignment(self)
            else:
                return visitor.visitChildren(self)


    class Stat_UntilContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def until(self):
            return self.getTypedRuleContext(ipdrawParser.UntilContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_Until" ):
                listener.enterStat_Until(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_Until" ):
                listener.exitStat_Until(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_Until" ):
                return visitor.visitStat_Until(self)
            else:
                return visitor.visitChildren(self)


    class Stat_pauseContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pause(self):
            return self.getTypedRuleContext(ipdrawParser.PauseContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_pause" ):
                listener.enterStat_pause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_pause" ):
                listener.exitStat_pause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_pause" ):
                return visitor.visitStat_pause(self)
            else:
                return visitor.visitChildren(self)


    class Stat_ifContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def if_(self):
            return self.getTypedRuleContext(ipdrawParser.IfContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_if" ):
                listener.enterStat_if(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_if" ):
                listener.exitStat_if(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_if" ):
                return visitor.visitStat_if(self)
            else:
                return visitor.visitChildren(self)


    class Stat_printContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def print_(self):
            return self.getTypedRuleContext(ipdrawParser.PrintContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_print" ):
                listener.enterStat_print(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_print" ):
                listener.exitStat_print(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_print" ):
                return visitor.visitStat_print(self)
            else:
                return visitor.visitChildren(self)


    class Stat_interactadorContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def interactador(self):
            return self.getTypedRuleContext(ipdrawParser.InteractadorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_interactador" ):
                listener.enterStat_interactador(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_interactador" ):
                listener.exitStat_interactador(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_interactador" ):
                return visitor.visitStat_interactador(self)
            else:
                return visitor.visitChildren(self)


    class Stat_penCmdContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def penCommand(self):
            return self.getTypedRuleContext(ipdrawParser.PenCommandContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_penCmd" ):
                listener.enterStat_penCmd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_penCmd" ):
                listener.exitStat_penCmd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_penCmd" ):
                return visitor.visitStat_penCmd(self)
            else:
                return visitor.visitChildren(self)


    class Stat_CurlyContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.StatContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.StatContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_Curly" ):
                listener.enterStat_Curly(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_Curly" ):
                listener.exitStat_Curly(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_Curly" ):
                return visitor.visitStat_Curly(self)
            else:
                return visitor.visitChildren(self)


    class Stat_varDeclarationContext(StatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.StatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def varDeclaration(self):
            return self.getTypedRuleContext(ipdrawParser.VarDeclarationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_varDeclaration" ):
                listener.enterStat_varDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_varDeclaration" ):
                listener.exitStat_varDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat_varDeclaration" ):
                return visitor.visitStat_varDeclaration(self)
            else:
                return visitor.visitChildren(self)



    def stat(self):

        localctx = ipdrawParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stat)
        self._la = 0 # Token type
        try:
            self.state = 48
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                localctx = ipdrawParser.Stat_penCmdContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 32
                self.penCommand()
                pass

            elif la_ == 2:
                localctx = ipdrawParser.Stat_ifContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 33
                self.if_()
                pass

            elif la_ == 3:
                localctx = ipdrawParser.Stat_UntilContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 34
                self.until()
                pass

            elif la_ == 4:
                localctx = ipdrawParser.Stat_printContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 35
                self.print_()
                pass

            elif la_ == 5:
                localctx = ipdrawParser.Stat_CurlyContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 36
                self.match(ipdrawParser.T__0)
                self.state = 40
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & 19870374137691338) != 0):
                    self.state = 37
                    self.stat()
                    self.state = 42
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 43
                self.match(ipdrawParser.T__1)
                pass

            elif la_ == 6:
                localctx = ipdrawParser.Stat_varAssignmentContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 44
                self.varAssignment()
                pass

            elif la_ == 7:
                localctx = ipdrawParser.Stat_varDeclarationContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 45
                self.varDeclaration()
                pass

            elif la_ == 8:
                localctx = ipdrawParser.Stat_pauseContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 46
                self.pause()
                pass

            elif la_ == 9:
                localctx = ipdrawParser.Stat_interactadorContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 47
                self.interactador()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PenCommandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ipdrawParser.RULE_penCommand

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class PenCmd_upContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_up" ):
                listener.enterPenCmd_up(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_up" ):
                listener.exitPenCmd_up(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_up" ):
                return visitor.visitPenCmd_up(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_leftContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.penRotateUnits = None # Token
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_left" ):
                listener.enterPenCmd_left(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_left" ):
                listener.exitPenCmd_left(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_left" ):
                return visitor.visitPenCmd_left(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_thicknessContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_thickness" ):
                listener.enterPenCmd_thickness(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_thickness" ):
                listener.exitPenCmd_thickness(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_thickness" ):
                return visitor.visitPenCmd_thickness(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_downContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_down" ):
                listener.enterPenCmd_down(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_down" ):
                listener.exitPenCmd_down(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_down" ):
                return visitor.visitPenCmd_down(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_rightContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.penRotateUnits = None # Token
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_right" ):
                listener.enterPenCmd_right(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_right" ):
                listener.exitPenCmd_right(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_right" ):
                return visitor.visitPenCmd_right(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_posContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def point(self):
            return self.getTypedRuleContext(ipdrawParser.PointContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_pos" ):
                listener.enterPenCmd_pos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_pos" ):
                listener.exitPenCmd_pos(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_pos" ):
                return visitor.visitPenCmd_pos(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_pauseContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_pause" ):
                listener.enterPenCmd_pause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_pause" ):
                listener.exitPenCmd_pause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_pause" ):
                return visitor.visitPenCmd_pause(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_colorContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Color(self):
            return self.getToken(ipdrawParser.Color, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_color" ):
                listener.enterPenCmd_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_color" ):
                listener.exitPenCmd_color(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_color" ):
                return visitor.visitPenCmd_color(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_forwardContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_forward" ):
                listener.enterPenCmd_forward(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_forward" ):
                listener.exitPenCmd_forward(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_forward" ):
                return visitor.visitPenCmd_forward(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_backwardContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_backward" ):
                listener.enterPenCmd_backward(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_backward" ):
                listener.exitPenCmd_backward(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_backward" ):
                return visitor.visitPenCmd_backward(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_orientationContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.penRotateUnits = None # Token
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_orientation" ):
                listener.enterPenCmd_orientation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_orientation" ):
                listener.exitPenCmd_orientation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_orientation" ):
                return visitor.visitPenCmd_orientation(self)
            else:
                return visitor.visitChildren(self)


    class PenCmd_pressureContext(PenCommandContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.PenCommandContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPenCmd_pressure" ):
                listener.enterPenCmd_pressure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPenCmd_pressure" ):
                listener.exitPenCmd_pressure(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPenCmd_pressure" ):
                return visitor.visitPenCmd_pressure(self)
            else:
                return visitor.visitChildren(self)



    def penCommand(self):

        localctx = ipdrawParser.PenCommandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_penCommand)
        self._la = 0 # Token type
        try:
            self.state = 117
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [3]:
                localctx = ipdrawParser.PenCmd_posContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 50
                self.match(ipdrawParser.T__2)
                self.state = 52
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 51
                    self.match(ipdrawParser.T__3)


                self.state = 54
                self.point()
                self.state = 55
                self.match(ipdrawParser.T__4)
                pass
            elif token in [6]:
                localctx = ipdrawParser.PenCmd_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 57
                self.match(ipdrawParser.T__5)
                self.state = 59
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 58
                    self.match(ipdrawParser.T__3)


                self.state = 61
                self.match(ipdrawParser.Color)
                self.state = 62
                self.match(ipdrawParser.T__4)
                pass
            elif token in [7]:
                localctx = ipdrawParser.PenCmd_orientationContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 63
                self.match(ipdrawParser.T__6)
                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 64
                    self.match(ipdrawParser.T__3)


                self.state = 67
                self.expr(0)
                self.state = 69
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==8 or _la==9:
                    self.state = 68
                    localctx.penRotateUnits = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==8 or _la==9):
                        localctx.penRotateUnits = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 71
                self.match(ipdrawParser.T__4)
                pass
            elif token in [10]:
                localctx = ipdrawParser.PenCmd_thicknessContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 73
                self.match(ipdrawParser.T__9)
                self.state = 75
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 74
                    self.match(ipdrawParser.T__3)


                self.state = 77
                self.expr(0)
                self.state = 78
                self.match(ipdrawParser.T__4)
                pass
            elif token in [11]:
                localctx = ipdrawParser.PenCmd_pressureContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 80
                self.match(ipdrawParser.T__10)
                self.state = 82
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==4:
                    self.state = 81
                    self.match(ipdrawParser.T__3)


                self.state = 84
                self.expr(0)
                self.state = 85
                self.match(ipdrawParser.T__4)
                pass
            elif token in [12]:
                localctx = ipdrawParser.PenCmd_downContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 87
                self.match(ipdrawParser.T__11)
                self.state = 88
                self.match(ipdrawParser.T__4)
                pass
            elif token in [13]:
                localctx = ipdrawParser.PenCmd_upContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 89
                self.match(ipdrawParser.T__12)
                self.state = 90
                self.match(ipdrawParser.T__4)
                pass
            elif token in [14]:
                localctx = ipdrawParser.PenCmd_forwardContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 91
                self.match(ipdrawParser.T__13)
                self.state = 92
                self.expr(0)
                self.state = 93
                self.match(ipdrawParser.T__4)
                pass
            elif token in [15]:
                localctx = ipdrawParser.PenCmd_backwardContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 95
                self.match(ipdrawParser.T__14)
                self.state = 96
                self.expr(0)
                self.state = 97
                self.match(ipdrawParser.T__4)
                pass
            elif token in [16]:
                localctx = ipdrawParser.PenCmd_leftContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 99
                self.match(ipdrawParser.T__15)
                self.state = 100
                self.expr(0)
                self.state = 102
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==8 or _la==9:
                    self.state = 101
                    localctx.penRotateUnits = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==8 or _la==9):
                        localctx.penRotateUnits = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 104
                self.match(ipdrawParser.T__4)
                pass
            elif token in [17]:
                localctx = ipdrawParser.PenCmd_rightContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 106
                self.match(ipdrawParser.T__16)
                self.state = 107
                self.expr(0)
                self.state = 109
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==8 or _la==9:
                    self.state = 108
                    localctx.penRotateUnits = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==8 or _la==9):
                        localctx.penRotateUnits = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 111
                self.match(ipdrawParser.T__4)
                pass
            elif token in [18]:
                localctx = ipdrawParser.PenCmd_pauseContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 113
                self.match(ipdrawParser.T__17)
                self.state = 114
                self.expr(0)
                self.state = 115
                self.match(ipdrawParser.T__4)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(ipdrawParser.ID)
            else:
                return self.getToken(ipdrawParser.ID, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.ExprContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.ExprContext,i)


        def TYPE(self):
            return self.getToken(ipdrawParser.TYPE, 0)

        def getRuleIndex(self):
            return ipdrawParser.RULE_varAssignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarAssignment" ):
                listener.enterVarAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarAssignment" ):
                listener.exitVarAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarAssignment" ):
                return visitor.visitVarAssignment(self)
            else:
                return visitor.visitChildren(self)




    def varAssignment(self):

        localctx = ipdrawParser.VarAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_varAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 119
                self.match(ipdrawParser.TYPE)


            self.state = 122
            self.match(ipdrawParser.ID)

            self.state = 123
            self.match(ipdrawParser.T__3)
            self.state = 124
            self.expr(0)
            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==19:
                self.state = 126
                self.match(ipdrawParser.T__18)
                self.state = 127
                self.match(ipdrawParser.ID)
                self.state = 128
                self.match(ipdrawParser.T__3)
                self.state = 129
                self.expr(0)
                self.state = 134
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 136
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 135
                self.match(ipdrawParser.T__4)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TYPE(self):
            return self.getToken(ipdrawParser.TYPE, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(ipdrawParser.ID)
            else:
                return self.getToken(ipdrawParser.ID, i)

        def getRuleIndex(self):
            return ipdrawParser.RULE_varDeclaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDeclaration" ):
                listener.enterVarDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDeclaration" ):
                listener.exitVarDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDeclaration" ):
                return visitor.visitVarDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def varDeclaration(self):

        localctx = ipdrawParser.VarDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_varDeclaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 138
            self.match(ipdrawParser.TYPE)
            self.state = 139
            self.match(ipdrawParser.ID)
            self.state = 144
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==19:
                self.state = 140
                self.match(ipdrawParser.T__18)
                self.state = 141
                self.match(ipdrawParser.ID)
                self.state = 146
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 147
            self.match(ipdrawParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ipdrawParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Expr_parenthesisContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_parenthesis" ):
                listener.enterExpr_parenthesis(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_parenthesis" ):
                listener.exitExpr_parenthesis(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_parenthesis" ):
                return visitor.visitExpr_parenthesis(self)
            else:
                return visitor.visitChildren(self)


    class Expr_varContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(ipdrawParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_var" ):
                listener.enterExpr_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_var" ):
                listener.exitExpr_var(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_var" ):
                return visitor.visitExpr_var(self)
            else:
                return visitor.visitChildren(self)


    class Expr_boolContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BOOL(self):
            return self.getToken(ipdrawParser.BOOL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_bool" ):
                listener.enterExpr_bool(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_bool" ):
                listener.exitExpr_bool(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_bool" ):
                return visitor.visitExpr_bool(self)
            else:
                return visitor.visitChildren(self)


    class Expr_comparisonContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.ExprContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_comparison" ):
                listener.enterExpr_comparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_comparison" ):
                listener.exitExpr_comparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_comparison" ):
                return visitor.visitExpr_comparison(self)
            else:
                return visitor.visitChildren(self)


    class Expr_mulContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.ExprContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_mul" ):
                listener.enterExpr_mul(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_mul" ):
                listener.exitExpr_mul(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_mul" ):
                return visitor.visitExpr_mul(self)
            else:
                return visitor.visitChildren(self)


    class Expr_intContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INT(self):
            return self.getToken(ipdrawParser.INT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_int" ):
                listener.enterExpr_int(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_int" ):
                listener.exitExpr_int(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_int" ):
                return visitor.visitExpr_int(self)
            else:
                return visitor.visitChildren(self)


    class Expr_pointContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def point(self):
            return self.getTypedRuleContext(ipdrawParser.PointContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_point" ):
                listener.enterExpr_point(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_point" ):
                listener.exitExpr_point(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_point" ):
                return visitor.visitExpr_point(self)
            else:
                return visitor.visitChildren(self)


    class Expr_sumContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.ExprContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_sum" ):
                listener.enterExpr_sum(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_sum" ):
                listener.exitExpr_sum(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_sum" ):
                return visitor.visitExpr_sum(self)
            else:
                return visitor.visitChildren(self)


    class Expr_orContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.ExprContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_or" ):
                listener.enterExpr_or(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_or" ):
                listener.exitExpr_or(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_or" ):
                return visitor.visitExpr_or(self)
            else:
                return visitor.visitChildren(self)


    class Expr_REALContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REAL(self):
            return self.getToken(ipdrawParser.REAL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_REAL" ):
                listener.enterExpr_REAL(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_REAL" ):
                listener.exitExpr_REAL(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_REAL" ):
                return visitor.visitExpr_REAL(self)
            else:
                return visitor.visitChildren(self)


    class Expr_stringContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(ipdrawParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_string" ):
                listener.enterExpr_string(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_string" ):
                listener.exitExpr_string(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_string" ):
                return visitor.visitExpr_string(self)
            else:
                return visitor.visitChildren(self)


    class Expr_andContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.ExprContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_and" ):
                listener.enterExpr_and(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_and" ):
                listener.exitExpr_and(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_and" ):
                return visitor.visitExpr_and(self)
            else:
                return visitor.visitChildren(self)


    class Expr_notContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ipdrawParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr_not" ):
                listener.enterExpr_not(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr_not" ):
                listener.exitExpr_not(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_not" ):
                return visitor.visitExpr_not(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = ipdrawParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 10
        self.enterRecursionRule(localctx, 10, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                localctx = ipdrawParser.Expr_parenthesisContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 150
                self.match(ipdrawParser.T__19)
                self.state = 151
                self.expr(0)
                self.state = 152
                self.match(ipdrawParser.T__20)
                pass

            elif la_ == 2:
                localctx = ipdrawParser.Expr_notContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 154
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==22 or _la==23):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 155
                self.expr(12)
                pass

            elif la_ == 3:
                localctx = ipdrawParser.Expr_REALContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 156
                self.match(ipdrawParser.REAL)
                pass

            elif la_ == 4:
                localctx = ipdrawParser.Expr_intContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 157
                self.match(ipdrawParser.INT)
                pass

            elif la_ == 5:
                localctx = ipdrawParser.Expr_boolContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 158
                self.match(ipdrawParser.BOOL)
                pass

            elif la_ == 6:
                localctx = ipdrawParser.Expr_varContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 159
                self.match(ipdrawParser.ID)
                pass

            elif la_ == 7:
                localctx = ipdrawParser.Expr_pointContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 160
                self.point()
                pass

            elif la_ == 8:
                localctx = ipdrawParser.Expr_stringContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 161
                self.match(ipdrawParser.STRING)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 181
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 179
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                    if la_ == 1:
                        localctx = ipdrawParser.Expr_andContext(self, ipdrawParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 164
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 165
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==24 or _la==25):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 166
                        self.expr(12)
                        pass

                    elif la_ == 2:
                        localctx = ipdrawParser.Expr_orContext(self, ipdrawParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 167
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 168
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 469762048) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 169
                        self.expr(11)
                        pass

                    elif la_ == 3:
                        localctx = ipdrawParser.Expr_comparisonContext(self, ipdrawParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 170
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 171
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 33822867456) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 172
                        self.expr(10)
                        pass

                    elif la_ == 4:
                        localctx = ipdrawParser.Expr_mulContext(self, ipdrawParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 173
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 174
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 2164663517184) != 0)):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 175
                        self.expr(9)
                        pass

                    elif la_ == 5:
                        localctx = ipdrawParser.Expr_sumContext(self, ipdrawParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 176
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 177
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==41 or _la==42):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 178
                        self.expr(8)
                        pass

             
                self.state = 183
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class IfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def stat(self):
            return self.getTypedRuleContext(ipdrawParser.StatContext,0)


        def getRuleIndex(self):
            return ipdrawParser.RULE_if

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf" ):
                listener.enterIf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf" ):
                listener.exitIf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIf" ):
                return visitor.visitIf(self)
            else:
                return visitor.visitChildren(self)




    def if_(self):

        localctx = ipdrawParser.IfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_if)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.match(ipdrawParser.T__42)
            self.state = 185
            self.match(ipdrawParser.T__19)
            self.state = 186
            self.expr(0)
            self.state = 187
            self.match(ipdrawParser.T__20)
            self.state = 188
            self.stat()
            self.state = 190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 189
                self.match(ipdrawParser.T__4)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UntilContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def stat(self):
            return self.getTypedRuleContext(ipdrawParser.StatContext,0)


        def getRuleIndex(self):
            return ipdrawParser.RULE_until

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUntil" ):
                listener.enterUntil(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUntil" ):
                listener.exitUntil(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUntil" ):
                return visitor.visitUntil(self)
            else:
                return visitor.visitChildren(self)




    def until(self):

        localctx = ipdrawParser.UntilContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_until)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.match(ipdrawParser.T__43)
            self.state = 193
            self.match(ipdrawParser.T__19)
            self.state = 194
            self.expr(0)
            self.state = 195
            self.match(ipdrawParser.T__20)
            self.state = 196
            self.stat()
            self.state = 198
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.state = 197
                self.match(ipdrawParser.T__4)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.id_ = None # Token
            self.s = None # Token

        def ID(self):
            return self.getToken(ipdrawParser.ID, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(ipdrawParser.STRING)
            else:
                return self.getToken(ipdrawParser.STRING, i)

        def getRuleIndex(self):
            return ipdrawParser.RULE_print

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrint" ):
                listener.enterPrint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrint" ):
                listener.exitPrint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrint" ):
                return visitor.visitPrint(self)
            else:
                return visitor.visitChildren(self)




    def print_(self):

        localctx = ipdrawParser.PrintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_print)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [50]:
                self.state = 200
                localctx.id_ = self.match(ipdrawParser.ID)
                pass
            elif token in [54]:
                self.state = 202 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 201
                    localctx.s = self.match(ipdrawParser.STRING)
                    self.state = 204 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==54):
                        break

                pass
            else:
                raise NoViableAltException(self)

            self.state = 208
            self.match(ipdrawParser.T__44)
            self.state = 209
            self.match(ipdrawParser.T__45)
            self.state = 210
            self.match(ipdrawParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(ipdrawParser.ExprContext,0)


        def getRuleIndex(self):
            return ipdrawParser.RULE_pause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPause" ):
                listener.enterPause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPause" ):
                listener.exitPause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPause" ):
                return visitor.visitPause(self)
            else:
                return visitor.visitChildren(self)




    def pause(self):

        localctx = ipdrawParser.PauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_pause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(ipdrawParser.T__17)
            self.state = 213
            self.expr(0)
            self.state = 214
            self.match(ipdrawParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InteractadorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ipdrawParser.RULE_interactador

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInteractador" ):
                listener.enterInteractador(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInteractador" ):
                listener.exitInteractador(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInteractador" ):
                return visitor.visitInteractador(self)
            else:
                return visitor.visitChildren(self)




    def interactador(self):

        localctx = ipdrawParser.InteractadorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_interactador)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(ipdrawParser.T__46)
            self.state = 218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 217
                self.match(ipdrawParser.T__4)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PointContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ipdrawParser.ExprContext)
            else:
                return self.getTypedRuleContext(ipdrawParser.ExprContext,i)


        def getRuleIndex(self):
            return ipdrawParser.RULE_point

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPoint" ):
                listener.enterPoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPoint" ):
                listener.exitPoint(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPoint" ):
                return visitor.visitPoint(self)
            else:
                return visitor.visitChildren(self)




    def point(self):

        localctx = ipdrawParser.PointContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_point)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            self.match(ipdrawParser.T__19)
            self.state = 221
            self.expr(0)
            self.state = 222
            self.match(ipdrawParser.T__18)
            self.state = 223
            self.expr(0)
            self.state = 224
            self.match(ipdrawParser.T__20)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[5] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 7)
         




